#!/bin/bash

# globals
# --------------------------------------------------
_bold=`tput bold`
_normal=`tput sgr0`
# @ is not expanded by bash or zsh
_glob="@"



# directories and imports
# --------------------------------------------------

# start by getting script path even if it was executed via symlink. will work in bash, sh, ksh (not bsd)
scriptpath=`readlink -f $0 2>/dev/null`

# will work in tcsh, csh (and bsd)
if [ $? -ne 0 ]; then
  scriptpath=`readlink $0 2>/dev/null`

  # will work if script was not executed via symlink
  if [ $? -ne 0 ]; then
    scriptpath=`echo $0`
  fi
fi

rootdir=$(dirname "${scriptpath}")
rootdir="$(dirname "$rootdir")" # up from bin to root directory
name=$(basename ${scriptpath})
# import user-defined variables
source "${rootdir}/_config/env.sh"
# import helpers
source "${rootdir}/_helpers/helpers.sh"
# attempt to cd into notes directory
cd ${_dir} 2>/dev/null; dir=`pwd -P`; cd ${dir}


optstring=":Cdf:F:him:n:N:Op:Pr:R:"
# completions options that need to be parsed before potentially exiting program
# --------------------------------------------------
while getopts "$optstring" opt; do
  case $opt in

    # path to init script for loading custom tab completions
    # ------------------------------
    i)
      echo "${rootdir}/_completions/init.sh"
      exit 0
    ;;

    # custom completions function for returning a list of all notes to be parsed by completions functions
    # ------------------------------
    C)
      # ignore directories, ignore hidden files, remove leading ./ with sed, remove extension
      for note in `find . -type f -name "*${_ext}" ! -path "*/\.*" 2>/dev/null \
      | sed 's/^\.\///'`; do echo "${note%.*}"; done
      exit 0
    ;;

    # prompt user to set a new notes directory
    # ------------------------------
    d)
      setdir ""
      exit 0
    ;;

  esac
done


# prompt user to enter valid notes directory, and update _config/env.sh
if [ ! -d "${_dir}" ]; then
  setdir "${_dir}"
fi


# reset options index
OPTIND=1
# parse options and arguments
# --------------------------------------------------
while getopts "$optstring" opt; do
  case $opt in

    # invoke usage function to print help to the screen
    # ------------------------------
    h)
      usage
      exit 0
    ;;

    # open notes directory
    # ------------------------------
    O)
      open .
      exit 0
    ;;

    # print contents of note
    # ------------------------------
    p)
      checknote "$OPTARG"
      less "$OPTARG${_ext}"
      exit 0
    ;;

    # print path to notes directory
    # ------------------------------
    P)
      if [ -z "$2" ]; then
        echo "${dir}"
      else
        checknoteordir "$2"
        echo "${dir}/${2}"
      fi
      exit 0
    ;;

    # create a new note
    # ------------------------------
    n)
      checkname "$OPTARG"
      mkdir -p $(dirname "$OPTARG${_ext}") && touch "$OPTARG${_ext}"
      open "$OPTARG${_ext}"
      exit 0
    ;;

    # create a new directory
    # ------------------------------
    N)
      checkname "$OPTARG"
      mkdir -p "$OPTARG"
      exit 0
    ;;

    # remove (delete) a note
    # ------------------------------
    r)
      checknote $OPTARG
      rm "$OPTARG${_ext}"
      exit 0
    ;;

    # remove (delete) a directory
    # ------------------------------
    R)
      checkdir $OPTARG
      rm -dr "$OPTARG"
      exit 0
    ;;

    # move a note (change its name). overwriting an existing note is not allowed
    # ------------------------------
    m)
      checknote $OPTARG
      checkname "${@:$OPTIND:1}"
      if [ -f ${@:$OPTIND:1}${_ext} ]; then
        echo "the note ${_bold}${@:$OPTIND:1}${_normal} already exists, and can not be overwritten with the -m option"
        exit 1
      fi

      mv $OPTARG${_ext} ${@:$OPTIND:1}${_ext}
      exit 0
    ;;

    f)
      egrep -ri $OPTARG .
      exit 0
    ;;

    F)
      egrep -ril $OPTARG .
      exit 0
    ;;

    # error messages
    # ------------------------------
    \?)
      echo "invalid option: -$OPTARG"
      usage
      exit 1
    ;;
    :)
      echo "error: option -$OPTARG requires an argument"
      usage
      exit 1
    ;;
  esac
done



# list all notes (if no args are passed). this function uses find, which allows it to recursively list notes in all subdirectories of notes directory
# ------------------------------
if [ -z "$1" ]; then
  previewnotes .
  exit 0
fi


# open note, or list all notes within a directory (if one arg is passed)
# ------------------------------
if [ -z "$2" ]; then

  if [ ! -f "$1${_ext}" ]; then
    if [ ! -d "$1" ]; then
      echo "neither the note nor directory ${_bold}$1${_normal} exists"
      exit 1
    fi
    previewnotes $1
    exit 0
  fi

  open $1${_ext}
  exit 0
fi


# pass note or directory as argument to another program (if two args are passed)
# ------------------------------
checkexec `echo $1 | awk '{ print $1; }'` # make sure first argument is an executable
if [ -z "$3" ]; then

  argument=""

  if [[ "$2" == *"${_glob}"* ]]; then
    glob_pattern=`echo $2 | sed "s/${_glob}/.*/g"`

    argument=`find . -type f ! -path "*/\.*" 2>/dev/null | grep "${glob_pattern}"`

    if [ -z "$argument" ]; then
      echo "globbing error for pattern ${_bold}${glob_pattern}${_normal}: no such notes exist"
      exit
    fi

    $1 ${argument} 2>/dev/null

  else
    checknoteordir $2
    if [ -f "$2${_ext}" ]; then
      $1 $2${_ext}
      exit $?
    fi
    $1 $2
  fi

  # exit with status code from last command
  exit $?
fi


# pass notes as arguments to another program (if more than two args are passed)
# ------------------------------
program=$1
shift

echo $@
noteargs=""
for note in $@; do
  checknote $note
  noteargs="${noteargs}`echo $note`${_ext} ";
done
$program ${noteargs}
exit 0
