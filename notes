#!/bin/bash

# globals
# --------------------------------------------------
_bold=`tput bold`
_normal=`tput sgr0`
# @ is not expanded by bash or zsh
_glob="@"



# directories and imports
# --------------------------------------------------

# start by getting script path even if it was executed via symlink. will work in bash, sh, ksh (not bsd)
scriptpath=`readlink -f $0 2>/dev/null`

# will work in tcsh, csh (and bsd)
if [ $? -ne 0 ]; then
  scriptpath=`readlink $0 2>/dev/null`

  # will work if script was not executed via symlink
  if [ $? -ne 0 ]; then
    scriptpath=`echo $0`
  fi
fi

rootdir=$(dirname ${scriptpath})
name=$(basename ${scriptpath})
# import user-defined variables
source "${rootdir}/_config/env.sh"
# import helpers
source "${rootdir}/_helpers/helpers.sh"
# attempt to cd into notes directory
cd ${_dir} 2>/dev/null; dir=`pwd -P`; cd ${dir}



# completions options that need to be parsed before potentially exiting program
# --------------------------------------------------
while getopts ":iC" opt; do
  case $opt in

    # path to init script for loading custom tab completions
    # ------------------------------
    i)
      echo "${rootdir}/_completions/init.sh"
      exit 0
    ;;

    # custom completions function for returning a list of all notes to be parsed by completions functions
    # ------------------------------
    C)
      # ignore directories, ignore hidden files, remove leading ./ with sed, remove extension
      for note in `find . -type f -name "*${_ext}" ! -path "*/\.*" 2>/dev/null \
      | sed 's/^\.\///'`; do echo "${note%.*}"; done
      exit 0
    ;;

  esac
done



# if notes directory doesn't exist, prompt user to enter valid notes directory, and update _config/env.sh
if [ ! -d "${_dir}" ]; then
  while [[ ! -d "${_dir}" ]]; do
    printf "\n${_bold}${_dir}${_normal} is not a valid notes directory\n"
    printf "Enter the FULL PATH to your notes directory:\n"
    read _dir
  done
  printf "_ext=${_ext}\n_dir=${_dir}" > "${rootdir}/_config/env.sh"
  exit 1
fi



# parse options and arguments
# --------------------------------------------------
while getopts ":hc:f:F:l:L:m:n:N:Op:Pr:R:" opt; do
  case $opt in

    # invoke usage function to print help to the screen
    # ------------------------------
    h)
      usage
      exit 0
    ;;

    # open notes directory
    # ------------------------------
    O)
      open .
      exit 0
    ;;

    # print contents of note
    # ------------------------------
    p)
      checknote "$OPTARG"
      less "$OPTARG${_ext}"
      exit 0
    ;;

    # print path to notes directory
    # ------------------------------
    P)
      if [ -z "$2" ]; then
        echo "${dir}"
      else
        checknoteordir "$2"
        echo "${dir}/${2}"
      fi
      exit 0
    ;;

    # create a new note
    # ------------------------------
    n)
      checkname "$OPTARG"
      mkdir -p $(dirname "$OPTARG${_ext}") && touch "$OPTARG${_ext}"
      open "$OPTARG${_ext}"
      exit 0
    ;;

    # create a new directory
    # ------------------------------
    N)
      checkname "$OPTARG"
      mkdir -p "$OPTARG"
      exit 0
    ;;

    # remove (delete) a note
    # ------------------------------
    r)
      checknote $OPTARG
      rm "$OPTARG${_ext}"
      exit 0
    ;;

    # remove (delete) a directory
    # ------------------------------
    R)
      checkdir $OPTARG
      rm -dr "$OPTARG"
      exit 0
    ;;

    # move a note (change its name). overwriting an existing note is not allowed
    # ------------------------------
    m)
      checknote $OPTARG
      checkname "${@:$OPTIND:1}"
      if [ -f ${@:$OPTIND:1}${_ext} ]; then
        echo "the note ${_bold}${@:$OPTIND:1}${_normal} already exists, and can not be overwritten with the -m option"
        exit 1
      fi

      mv $OPTARG${_ext} ${@:$OPTIND:1}${_ext}
      exit 0
    ;;

    # show paths of all notes under home directory with same inode as this note (notes connected by hard links)
    # ------------------------------
    l)
      checknote $OPTARG
      find ~ -inum `ls -i ${OPTARG}${_ext} | awk '{print $1}'` ! -path "${dir}/*" -xdev 2>/dev/null
      exit 0
    ;;

    # create a hard link between source note and target note. source note must exist in notes directory
    # ------------------------------
    L)
      checknote $OPTARG
      shift; shift
      ln "$OPTARG${_ext}" $1
      exit 0
    ;;

    # combine notes (does not delete notes that were combined with target note, creates a new target note if target note did not exist)
    # ------------------------------
    c)
      checkname "$OPTARG"
      tgt=$OPTARG${_ext}
      # shift pass -c and $OPTARG
      shift; shift

      tgtexists=""
      if [ -f $tgt ]; then
        tgtexists=1
      fi

      until [ -z "$1" ]
      do
        if [ -f $1${_ext} ]; then

          if [ -z $tgtexists ]; then
            tgtexists=1
          else
            printf "\n______________________________\n" >> $tgt
          fi

          cat $1${_ext} >> $tgt
        else
          echo "the note ${_bold}$1${_normal} does not exist"
        fi
        shift
      done

      exit 0
    ;;

    f)
      egrep -ri $OPTARG .
      exit 0
    ;;

    F)
      egrep -ril $OPTARG .
      exit 0
    ;;


    # error messages
    # ------------------------------
    \?)
      echo "invalid option: -$OPTARG"
      usage
      exit 1
    ;;
    :)
      echo "error: option -$OPTARG requires an argument"
      usage
      exit 1
    ;;
  esac
done





# if standard input is empty
# --------------------------------------------------
if [ -t 0 ]; then

  # list all notes (if no args are passed). this function uses find, which allows it to recursively list notes in all subdirectories of notes directory
  # ------------------------------
  if [ -z "$1" ]; then
    previewnotes .
    exit 0
  fi



  # open note, or list all notes within a directory (if one arg is passed)
  # ------------------------------
  if [ -z "$2" ]; then

    if [ ! -f "$1${_ext}" ]; then
      if [ ! -d "$1" ]; then
        echo "neither the note nor directory ${_bold}$1${_normal} exists"
        exit 1
      fi
      previewnotes $1
      exit 0
    fi

    open $1${_ext}
    exit 0
  fi



  # pass note or directory as argument to another program (if two args are passed)
  # ------------------------------

  # make sure first argument is an executable
  checkexec `echo $1 | awk '{ print $1; }'`

  if [ -z "$3" ]; then

    argument=""

    if [[ "$2" == *"${_glob}"* ]]; then
      glob_pattern=`echo $2 | sed "s/${_glob}/.*/g"`

      argument=`find . -type f ! -path "*/\.*" 2>/dev/null | grep "${glob_pattern}"`

      if [ -z "$argument" ]; then
        echo "globbing error for pattern ${_bold}${glob_pattern}${_normal}: no such notes exist"
        exit
      fi

      $1 ${argument} 2>/dev/null

    else
      checknoteordir $2
      if [ -f "$2${_ext}" ]; then
        $1 $2${_ext}
        exit $?
      fi
      $1 $2
    fi

    # exit with status code from last command
    exit $?
  fi


  # pass notes as arguments to another program (if more than two args are passed)
  # ------------------------------
  program=$1
  shift

  echo $@
  noteargs=""
  for note in $@; do
    checknote $note
    noteargs="${noteargs}`echo $note`${_ext} ";
  done
  $program ${noteargs}
  exit 0



# if standard input is not empty
# --------------------------------------------------
else

  checkname "$1"
  if [ -z "$1" ]; then
    echo "to read from stdin and append to a note, a note must be specified"
    exit 1
  fi

  # when reading from stdin a new note is created if the note specified does not exist. printf preserves whitespace, unlike echo
  echo "" >> $1${_ext}
  while IFS='' read -r line; do
    printf "%s\n" "$line" >> $1${_ext}
  done
fi
exit 0

