#!/bin/bash

# globals
# --------------------------------------------------
_ext=".md"
_bold=`tput bold`
_normal=`tput sgr0`
# @ is not expanded by bash or zsh
_glob="@"

# these parameters should not be modified
_notes_dir="_notes"
_completions_dir="_completions"
_completions_init_script="init.sh"





# functions
# --------------------------------------------------
function checknote {
  if [ ! -f "$1${_ext}" ]; then
    echo "the note ${_bold}$1${_normal} does not exist"
    exit 1
  fi
}

function checkdir {
  if [ ! -d "$1" ]; then
    echo "the directory ${_bold}$1${_normal} does not exist"
    exit 1
  fi
}

function checknoteordir {
  if [ ! -f "$1${_ext}" ] && [ ! -d "$1" ]; then
    echo "neither the note nor directory ${_bold}$1${_normal} exists"
    exit 1
  fi
}

# hash is faster than which
function checkexec {
  if hash $1 2>/dev/null; then
    :
  else
    echo "the executable ${_bold}$1${_normal} does not exist"
    exit 1
  fi
}

function checkname {
  if echo $1 | grep -E "[[:space:]]" >/dev/null; then
    echo "neither note nor directory names may contain whitespace characters"
    exit 1
  fi
}


function previewnotes {

  TRAILINGSPACES=50
  INDENT="     "
  MAXCHARS=25
  DESCRIPTIONCHARS=50

  # ignore parent directory, ignore hidden files and directories, ignore files without proper extension
  find ${1} ! -path ${1} ! -path "*/\.*" \( -type f -name "*${_ext}" -or -type d \) 2>/dev/null \
  | while read x; do
    # remove leading ./ with cut, replace remaining path segments with indent spaces, then remove all non-space chars
    indent=`echo $x | cut -c 3- | sed -E "s:[^/]+/:$INDENT:g" | sed -E "s/[^ ]//g"`

    # get basename of note without extension, and trim excessively long names
    name=`basename "$x" | cut -d. -f1`
    name=${name:0:$MAXCHARS}

    numspaces=$[$TRAILINGSPACES - ${#name}]
    spaces=`head -c $numspaces < /dev/zero | tr '\0' ' '`

    if [ -f $x ]; then
      desc="`head -c $DESCRIPTIONCHARS $x | tr '\n' ' ' 2>/dev/null`..."
      echo -e "${indent}${_bold}${name}${_normal}${spaces}${desc}"

    elif [ -d $x ]; then
      desc="/"
      echo -e "${indent}${name}${spaces}${desc}"

    fi
  done

}





# directories
# --------------------------------------------------

# start by getting script path even if it was executed via symlink. will work in bash, sh, ksh (not bsd)
fullpath=`readlink -f $0 2>/dev/null`

# will work in tcsh, csh (and bsd)
if [ $? -ne 0 ]; then
  fullpath=`readlink $0 2>/dev/null`

  # will work if script was not executed via symlink
  if [ $? -ne 0 ]; then
    fullpath=`echo $0`
  fi
fi

name=$(basename ${fullpath})
root_dir=$(dirname ${fullpath})

dir="${root_dir}/${_notes_dir}"
# cd into physical notes directory
cd $dir; dir=`pwd -P`; cd $dir



# help
# --------------------------------------------------
unset usage
usage() {
  cat << EOF

${_bold}NAME${_normal}
    ${_bold}${name}${_normal}

${_bold}SYNOPSIS${_normal}
    ${_bold}${name}${_normal} [${_bold}-hclLmnNOpPrR${_normal}] note ...

${_bold}DESCRIPTION${_normal}
    [ ${_bold}-h${_normal} ]                                  get help (display this page)
    [ ${_bold}-c${_normal} TGT_NOTE NOTE_A NOTE_B ... ]       combine notes: append text in notes a,b,... to target note. can be used to copy a note**
    [ ${_bold}-f${_normal} PATTERN ]                          find notes: search for notes matching pattern (all matches)
    [ ${_bold}-F${_normal} PATTERN ]                          find notes: search for notes matching pattern (note names only)
    [ ${_bold}-l${_normal} NOTE ]                             show paths of all notes under home directory with same inode as this note (notes connected by hard links)
    [ ${_bold}-L${_normal} SOURCE_NOTE TARGET_NOTE ]          create a hard link between source note and target note. source note must exist in notes directory
    [ ${_bold}-m${_normal} NOTE NEW_NOTE ]                    move a note (change its name). can not be used to overwrite an existing note
    [ ${_bold}-n${_normal} NEW_NOTE ]                         create and open a note
    [ ${_bold}-N${_normal} NEW_DIR ]                          create a directory
    [ ${_bold}-O${_normal} ]                                  open notes directory
    [ ${_bold}-p${_normal} NOTE ]                             print contents of note
    [ ${_bold}-P${_normal} [NOTE_OR_DIR] ]                    print full path to note or directory
    [ ${_bold}-r${_normal} NOTE ]                             remove (delete) a note
    [ ${_bold}-R${_normal} DIR ]                              remove (delete) a directory

    **
      ${name} -c copy original


    All of these options are mutually exclusive, i.e. at most one option should be passed to ${_bold}${name}${_normal}.


    If ${_bold}${name}${_normal} is invoked without any options, the following modes of execution exist:

      - zero arguments        :                             list all notes
      - one argument          <note_or_dir>:                open this note, or list all notes under this directory
      - two arguments         <program> <note_or_dir>:      pass note or directory as argument to program
      - two arguments         <program> <glob_pattern>:     pass all matched notes as arguments to program, simply replace ${_bold}*${_normal} with ${_bold}${_glob}${_normal}
      - g.t. two arguments    <program> <notes>:            pass notes as arguments to program

${_bold}EXAMPLES${_normal}
      - notes 'grep password' ${_glob}
      - notes open github

${_bold}EXTENSIONS${_normal}
      All notes have a default extension of ${_bold}${_ext}${_normal}, which is assigned to the variable ${_bold}_ext${_normal} in the source code of this program. Edit this variable to change or remove the extension. The extension should never be passed to ${_bold}notes${_normal} in any of its modes of execution.

EOF
}





# parse options and arguments
# --------------------------------------------------
while getopts ":hc:Cf:F:il:L:m:n:N:Op:Pr:R:" opt; do
  case $opt in

    # custom completions function for returning a list of all notes to be parsed by completions functions
    # ------------------------------
    C)
      # ignore directories, ignore hidden files, remove leading ./ with sed, remove extension
      for note in `find . -type f -name "*${_ext}" ! -path "*/\.*" 2>/dev/null \
      | sed 's/^\.\///'`; do echo "${note%.*}"; done
      exit 0
    ;;

    # path to init script for loading custom tab completions
    # ------------------------------
    i)
      echo ${root_dir}/${_completions_dir}/${_completions_init_script}
      exit 0
    ;;

    # invoke usage function to print help to the screen
    # ------------------------------
    h)
      usage
      exit 0
    ;;

    # open notes directory
    # ------------------------------
    O)
      open .
      exit 0
    ;;

    # print contents of note
    # ------------------------------
    p)
      checknote "$OPTARG"
      less "$OPTARG${_ext}"
      exit 0
    ;;

    # print path to notes directory
    # ------------------------------
    P)
      if [ -z "$2" ]; then
        echo "${dir}"
      else
        checknoteordir "$2"
        echo "${dir}/${2}"
      fi
      exit 0
    ;;

    # create a new note
    # ------------------------------
    n)
      checkname "$OPTARG"
      mkdir -p $(dirname "$OPTARG${_ext}") && touch "$OPTARG${_ext}"
      open "$OPTARG${_ext}"
      exit 0
    ;;

    # create a new directory
    # ------------------------------
    N)
      checkname "$OPTARG"
      mkdir -p "$OPTARG"
      exit 0
    ;;

    # remove (delete) a note
    # ------------------------------
    r)
      checknote $OPTARG
      rm "$OPTARG${_ext}"
      exit 0
    ;;

    # remove (delete) a directory
    # ------------------------------
    R)
      checkdir $OPTARG
      rm -dr "$OPTARG"
      exit 0
    ;;

    # move a note (change its name). overwriting an existing note is not allowed
    # ------------------------------
    m)
      checknote $OPTARG
      checkname "${@:$OPTIND:1}"
      if [ -f ${@:$OPTIND:1}${_ext} ]; then
        echo "the note ${_bold}${@:$OPTIND:1}${_normal} already exists, and can not be overwritten with the -m option"
        exit 1
      fi

      mv $OPTARG${_ext} ${@:$OPTIND:1}${_ext}
      exit 0
    ;;

    # show paths of all notes under home directory with same inode as this note (notes connected by hard links)
    # ------------------------------
    l)
      checknote $OPTARG
      find ~ -inum `ls -i ${OPTARG}${_ext} | awk '{print $1}'` ! -path "${dir}/*" -xdev 2>/dev/null
      exit 0
    ;;

    # create a hard link between source note and target note. source note must exist in notes directory
    # ------------------------------
    L)
      checknote $OPTARG
      shift; shift
      ln "$OPTARG${_ext}" $1
      exit 0
    ;;

    # combine notes (does not delete notes that were combined with target note, creates a new target note if target note did not exist)
    # ------------------------------
    c)
      checkname "$OPTARG"
      tgt=$OPTARG${_ext}
      # shift pass -c and $OPTARG
      shift; shift

      tgtexists=""
      if [ -f $tgt ]; then
        tgtexists=1
      fi

      until [ -z "$1" ]
      do
        if [ -f $1${_ext} ]; then

          if [ -z $tgtexists ]; then
            tgtexists=1
          else
            printf "\n______________________________\n" >> $tgt
          fi

          cat $1${_ext} >> $tgt
        else
          echo "the note ${_bold}$1${_normal} does not exist"
        fi
        shift
      done

      exit 0
    ;;

    f)
      egrep -ri $OPTARG .
      exit 0
    ;;

    F)
      egrep -ril $OPTARG .
      exit 0
    ;;


    # error messages
    # ------------------------------
    \?)
      echo "invalid option: -$OPTARG"
      usage
      exit 1
    ;;
    :)
      echo "error: option -$OPTARG requires an argument"
      usage
      exit 1
    ;;
  esac
done







# if standard input is empty
# --------------------------------------------------
if [ -t 0 ]; then

  # list all notes (if no args are passed). this function uses find, which allows it to recursively list notes in all subdirectories of notes directory
  # ------------------------------
  if [ -z "$1" ]; then
    previewnotes .
    exit 0
  fi



  # open note, or list all notes within a directory (if one arg is passed)
  # ------------------------------
  if [ -z "$2" ]; then

    if [ ! -f "$1${_ext}" ]; then
      if [ ! -d "$1" ]; then
        echo "neither the note nor directory ${_bold}$1${_normal} exists"
        exit 1
      fi
      previewnotes $1
      exit 0
    fi

    open $1${_ext}
    exit 0
  fi



  # pass note or directory as argument to another program (if two args are passed)
  # ------------------------------

  # make sure first argument is an executable
  checkexec `echo $1 | awk '{ print $1; }'`

  if [ -z "$3" ]; then

    argument=""

    if [[ "$2" == *"${_glob}"* ]]; then
      glob_pattern=`echo $2 | sed "s/${_glob}/.*/g"`

      argument=`find . -type f ! -path "*/\.*" 2>/dev/null | grep "${glob_pattern}"`

      if [ -z "$argument" ]; then
        echo "globbing error for pattern ${_bold}${glob_pattern}${_normal}: no such notes exist"
        exit
      fi

      $1 ${argument} 2>/dev/null

    else
      checknoteordir $2
      if [ -f "$2${_ext}" ]; then
        $1 $2${_ext}
        exit $?
      fi
      $1 $2
    fi

    # exit with status code from last command
    exit $?
  fi


  # pass notes as arguments to another program (if more than two args are passed)
  # ------------------------------
  program=$1
  shift

  echo $@
  noteargs=""
  for note in $@; do
    checknote $note
    noteargs="${noteargs}`echo $note`${_ext} ";
  done
  $program ${noteargs}
  exit 0




# if standard input is not empty
# --------------------------------------------------
else

  checkname "$1"
  if [ -z "$1" ]; then
    echo "to read from stdin and append to a note, a note must be specified"
    exit 1
  fi

  # when reading from stdin a new note is created if the note specified does not exist. printf preserves whitespace, unlike echo
  echo "" >> $1${_ext}
  while IFS='' read -r line; do
    # echo $line >> $1${_ext}
    printf "%s\n" "$line" >> $1${_ext}
  done
fi
exit 0

